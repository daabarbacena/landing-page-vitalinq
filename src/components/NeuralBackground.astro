---
interface Props {
  className?: string;
  color?: string;
  trailOpacity?: number;
  particleCount?: number;
  speed?: number;
}

const {
  className = "",
  color = "#673de6",
  trailOpacity = 0.05,
  particleCount = 600,
  speed = 0.5,
} = Astro.props;
---

<div class={`neural-background w-full h-full overflow-hidden ${className}`} style="filter: blur(3px); opacity: 0.3;">
  <canvas
    data-color={color}
    data-trail-opacity={trailOpacity}
    data-particle-count={particleCount}
    data-speed={speed}
    class="block w-full h-full"
  ></canvas>
</div>

<script>
  // Neural Background Animation with Canvas
  // Optimized for performance (Lighthouse)

  interface Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    age: number;
    life: number;
    update(): void;
    reset(): void;
    draw(context: CanvasRenderingContext2D): void;
  }

  class FlowParticle implements Particle {
    x: number;
    y: number;
    vx: number;
    vy: number;
    age: number;
    life: number;
    width: number;
    height: number;
    color: string;
    speed: number;
    mouse: { x: number; y: number };

    constructor(
      width: number,
      height: number,
      color: string,
      speed: number,
      mouse: { x: number; y: number }
    ) {
      this.width = width;
      this.height = height;
      this.color = color;
      this.speed = speed;
      this.mouse = mouse;
      this.x = Math.random() * width;
      this.y = Math.random() * height;
      this.vx = 0;
      this.vy = 0;
      this.age = 0;
      this.life = Math.random() * 200 + 100;
    }

    update(): void {
      // Flow Field Math
      const angle =
        (Math.cos(this.x * 0.005) + Math.sin(this.y * 0.005)) * Math.PI;

      this.vx += Math.cos(angle) * 0.2 * this.speed;
      this.vy += Math.sin(angle) * 0.2 * this.speed;

      // Mouse Interaction
      const dx = this.mouse.x - this.x;
      const dy = this.mouse.y - this.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const interactionRadius = 150;

      if (distance < interactionRadius) {
        const force = (interactionRadius - distance) / interactionRadius;
        this.vx -= dx * force * 0.05;
        this.vy -= dy * force * 0.05;
      }

      // Apply Velocity & Friction
      this.x += this.vx;
      this.y += this.vy;
      this.vx *= 0.95;
      this.vy *= 0.95;

      // Aging
      this.age++;
      if (this.age > this.life) {
        this.reset();
      }

      // Wrap around screen
      if (this.x < 0) this.x = this.width;
      if (this.x > this.width) this.x = 0;
      if (this.y < 0) this.y = this.height;
      if (this.y > this.height) this.y = 0;
    }

    reset(): void {
      this.x = Math.random() * this.width;
      this.y = Math.random() * this.height;
      this.vx = 0;
      this.vy = 0;
      this.age = 0;
      this.life = Math.random() * 200 + 100;
    }

    draw(context: CanvasRenderingContext2D): void {
      context.fillStyle = this.color;
      const alpha = 1 - Math.abs(this.age / this.life - 0.5) * 2;
      context.globalAlpha = alpha;
      context.fillRect(this.x, this.y, 1.5, 1.5);
    }
  }

  function initNeuralBackground() {
    const canvases = document.querySelectorAll(
      ".neural-background canvas"
    ) as NodeListOf<HTMLCanvasElement>;

    canvases.forEach((canvas) => {
      const ctx = canvas.getContext("2d");
      if (!ctx) return;

      const container = canvas.parentElement as HTMLElement;
      if (!container) return;

      const color = canvas.getAttribute("data-color") || "#673de6";
      const trailOpacity = parseFloat(
        canvas.getAttribute("data-trail-opacity") || "0.15"
      );
      const particleCount = parseInt(
        canvas.getAttribute("data-particle-count") || "600"
      );
      const speed = parseFloat(canvas.getAttribute("data-speed") || "1");

      let width = container.clientWidth;
      let height = container.clientHeight;
      let particles: FlowParticle[] = [];
      let animationFrameId: number;
      let mouse = { x: -1000, y: -1000 };

      const dpr = window.devicePixelRatio || 1;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      ctx.scale(dpr, dpr);
      canvas.style.width = `${width}px`;
      canvas.style.height = `${height}px`;

      // Initialize particles
      for (let i = 0; i < particleCount; i++) {
        particles.push(
          new FlowParticle(width, height, color, speed, mouse)
        );
      }

      // Animation loop with requestAnimationFrame
      const animate = () => {
        // Trail effect
        ctx.fillStyle = `rgba(0, 0, 0, ${trailOpacity})`;
        ctx.fillRect(0, 0, width, height);

        particles.forEach((p) => {
          p.update();
          p.draw(ctx);
        });

        animationFrameId = requestAnimationFrame(animate);
      };

      // Event listeners
      const handleResize = () => {
        width = container.clientWidth;
        height = container.clientHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);
      };

      const handleMouseMove = (e: MouseEvent) => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = e.clientX - rect.left;
        mouse.y = e.clientY - rect.top;
      };

      const handleMouseLeave = () => {
        mouse.x = -1000;
        mouse.y = -1000;
      };

      // Start animation
      animate();

      window.addEventListener("resize", handleResize);
      container.addEventListener("mousemove", handleMouseMove);
      container.addEventListener("mouseleave", handleMouseLeave);

      // Cleanup on page unload
      const cleanup = () => {
        window.removeEventListener("resize", handleResize);
        container.removeEventListener("mousemove", handleMouseMove);
        container.removeEventListener("mouseleave", handleMouseLeave);
        cancelAnimationFrame(animationFrameId);
      };

      window.addEventListener("beforeunload", cleanup);
    });
  }

  // Initialize on page load
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initNeuralBackground);
  } else {
    initNeuralBackground();
  }
</script>
